{"version":3,"sources":["components/dropdown/Dropdown.jsx","api/api.js","components/autocomplete/Autocomplete.jsx","App.jsx","reportWebVitals.js","index.js"],"names":["DropDown","suggestions","handleSelection","highlightedSuggestion","closeDropdown","dropdownRef","useRef","useEffect","document","addEventListener","handleOutsideClick","removeEventListener","e","current","contains","target","ref","className","length","map","suggestion","index","onClick","getRandomBool","n","maxRandomCoeff","Math","floor","random","getSuggestions","text","post","results","push","Promise","resolve","reject","randomTimeout","setTimeout","KEYBOARD_KEYS","Autocomplete","useState","setText","setSuggestions","setHighlightedSuggestion","inputRef","debouncedFunction","useCallback","debounce","getSuggestionsForWord","previousText","split","slice","join","console","log","resetSuggestions","focus","a","error","type","value","autoFocus","onChange","event","lastText","textToSearch","onInput","onKeyDown","keyPressed","which","onKeyPressed","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a476d62c.chunk.js","sourcesContent":["import React, { useEffect, useRef } from \"react\";\nimport \"./Dropdown.css\";\n\nconst DropDown = ({\n  suggestions,\n  handleSelection,\n  highlightedSuggestion,\n  closeDropdown,\n}) => {\n  const dropdownRef = useRef();\n\n  useEffect(() => {\n    document.addEventListener(\"mousedown\", handleOutsideClick, false);\n    return () => {\n      document.removeEventListener(\"mousedown\", handleOutsideClick, false);\n    };\n  }, []);\n\n  const handleOutsideClick = (e) => {\n    if (dropdownRef.current.contains(e.target)) {\n      return;\n    }\n\n    // Close the dropdown\n    closeDropdown();\n  };\n\n  return (\n    <ul\n      ref={dropdownRef}\n      className={`dropdown-menu dropdown-menu-end ${\n        suggestions.length > 0 ? \"show\" : \"hide\"\n      }`}\n    >\n      {suggestions.map((suggestion, index) => (\n        <li\n          className={`dropdown-item ${\n            highlightedSuggestion === index && \"highlight\"\n          }`}\n          key={suggestion}\n          onClick={() => handleSelection(suggestion)}\n        >\n          {suggestion}\n        </li>\n      ))}\n    </ul>\n  );\n};\n\nexport default DropDown;\n","//Mock API, Don't change anything here\n\nconst FAILURE_COEFF = 10;\nconst MAX_SERVER_LATENCY = 200;\n\nfunction getRandomBool(n) {\n  const maxRandomCoeff = 1000;\n  if (n > maxRandomCoeff) n = maxRandomCoeff;\n  return Math.floor(Math.random() * maxRandomCoeff) % n === 0;\n}\n\nfunction getSuggestions(text) {\n  const pre = \"pre\";\n  const post = \"post\";\n  const results = [];\n  if (getRandomBool(2)) {\n    results.push(pre + text);\n  }\n  if (getRandomBool(2)) {\n    results.push(text);\n  }\n  if (getRandomBool(2)) {\n    results.push(text + post);\n  }\n  if (getRandomBool(2)) {\n    results.push(pre + text + post);\n  }\n  return new Promise((resolve, reject) => {\n    const randomTimeout = Math.random() * MAX_SERVER_LATENCY;\n    setTimeout(() => {\n      if (getRandomBool(FAILURE_COEFF)) {\n        reject();\n      } else {\n        resolve(results);\n      }\n    }, randomTimeout);\n  });\n}\n\nexport default getSuggestions;","import React, { useCallback, useRef, useState } from \"react\";\nimport { debounce } from \"lodash\";\nimport DropDown from \"../dropdown/Dropdown\";\nimport getSuggestions from \"../../api/api\";\n\nconst KEYBOARD_KEYS = {\n  ENTER: 13,\n  UP_ARROW: 38,\n  DOWN_ARROW: 40,\n};\n\nconst Autocomplete = () => {\n  const [text, setText] = useState(\"\");\n  const [suggestions, setSuggestions] = useState([]);\n  const [highlightedSuggestion, setHighlightedSuggestion] = useState(0);\n  const inputRef = useRef();\n  const debouncedFunction = useCallback(debounce(getSuggestionsForWord, 400));\n\n  const onInput = (event) => {\n    const lastText = text.split(\" \").slice(-1)[0];\n    const textToSearch = event.target.value.split(\" \").slice(-1)[0];\n\n    setText(event.target.value);\n\n    // Checking if the last text is empty or the last word has changes\n    if (!!textToSearch && lastText !== textToSearch) {\n      debouncedFunction(textToSearch);\n    } else {\n      resetSuggestions();\n    }\n  };\n\n  const handleSelection = (suggestion) => {\n    const previousText = text.split(\" \").slice(0, -1).join(\" \");\n\n    console.log(previousText);\n    if (previousText.length > 1) {\n      setText(`${previousText} ${suggestion} `);\n    } else {\n      setText(`${suggestion} `);\n    }\n    resetSuggestions();\n    inputRef.current.focus();\n  };\n\n  const resetSuggestions = () => {\n    setSuggestions([]);\n    setHighlightedSuggestion(0);\n  };\n\n  const onKeyPressed = (e) => {\n    if (suggestions.length === 0) {\n      return;\n    }\n\n    const keyPressed = e.which;\n\n    if (keyPressed === KEYBOARD_KEYS.UP_ARROW) {\n      setHighlightedSuggestion(\n        highlightedSuggestion === 0\n          ? suggestions.length - 1\n          : highlightedSuggestion - 1\n      );\n    } else if (keyPressed === KEYBOARD_KEYS.DOWN_ARROW) {\n      setHighlightedSuggestion(\n        highlightedSuggestion === suggestions.length - 1\n          ? 0\n          : highlightedSuggestion + 1\n      );\n    } else if (keyPressed === KEYBOARD_KEYS.ENTER) {\n      handleSelection(suggestions[highlightedSuggestion]);\n    }\n  };\n\n  const getSuggestionsForWord = async (text) => {\n    try {\n      const suggestions = await getSuggestions(text);\n      setSuggestions(suggestions);\n      setHighlightedSuggestion(0);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return (\n    <div className=\"input-group\">\n      <input\n        type=\"text\"\n        ref={inputRef}\n        value={text}\n        autoFocus\n        onChange={(e) => onInput(e)}\n        onKeyDown={(e) => onKeyPressed(e)}\n        className=\"form-control\"\n      />\n      <DropDown\n        suggestions={suggestions}\n        handleSelection={handleSelection}\n        highlightedSuggestion={highlightedSuggestion}\n        closeDropdown={resetSuggestions}\n      />\n    </div>\n  );\n};\n\nexport default Autocomplete;\n","import \"./App.css\";\nimport Autocomplete from \"./components/autocomplete/Autocomplete\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Autocomplete />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}